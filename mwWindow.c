/***** * mwWindow.c * *		The window routines for the Mandy Fractal Generator * *****/#include <math.h>#include <stdio.h>#include "mwWindow.h"#ifndef _Quickdraw_#include <Quickdraw.h>#endif#define windowX 0#define windowY 40#define windowWidth 512#define windowHeight 300#define pi 3.14159265WindowPtr	mwWindow;Rect		dragRect;Rect		windowBounds = { windowY, windowX, windowY+windowHeight, windowX+windowWidth };Rect		imageStart = {0, 0, windowHeight, windowWidth};int			width = 5; /* SetUpWindow()   Create the Minimum Window window, and open it. */void SetUpWindow(void) {    dragRect = screenBits.bounds;        mwWindow = NewWindow(0L, &windowBounds, "\pFractal Window", true, noGrowDocProc, (WindowPtr) -1L, true, 0);    SetPort(mwWindow);}void DrawBranch(float x1, float y1, float angle, float depth) {	if (depth != 0) {		float x2 = x1 + cos(angle*(pi/180.0))*depth*10;		float y2 = y1 + sin(angle*(pi/180.0))*depth*10;				MoveTo(x1,windowHeight-y1);		Line(x2-x1,y1-y2);				DrawBranch(x2,y2,angle-20,depth-1);		DrawBranch(x2,y2,angle+20,depth-1);		}}void Julia() {    double cRe, cIm;                     //real and imaginary part of the constant c, determinate shape of the Julia Set    double newRe, newIm, oldRe, oldIm;   //real and imaginary parts of new and old    double zoom = 1, moveX = 0, moveY = 0; //you can change these to zoom and change position    int sizex = windowWidth, sizey = windowHeight;//    ColorRGB color; //the RGB color value for the pixel    int maxIterations = 300; //after how much iterations the function should stop	int x,y;    //pick some values for the constant c, this determines the shape of the Julia Set    cRe = -0.7;    cIm = 0.27015;    //loop through every pixel    for(x = 0; x < sizex; x+=2)    for(y = 0; y < sizey; y+=2)    {        //i will represent the number of iterations    	int i;        //calculate the initial real and imaginary part of z, based on the pixel location and zoom and position values        newRe = 1.5 * (x - sizex / 2) / (0.5 * zoom * sizex) + moveX;        newIm = (y - sizey / 2) / (0.5 * zoom * sizey) + moveY;        //start the iteration process        for(i = 0; i < maxIterations; i++)        {            //remember value of previous iteration            oldRe = newRe;            oldIm = newIm;            //the actual iteration, the real and imaginary part are calculated            newRe = oldRe * oldRe - oldIm * oldIm + cRe;            newIm = 2 * oldRe * oldIm + cIm;            //if the point is outside the circle with radius 2: stop            if((newRe * newRe + newIm * newIm) > 4) break;        }        //draw the pixel                 if (i>4) { //6 //12 //24                MoveTo(x,y);                if (i>32) {                	Line (1,0);                	MoveTo(x,y+1);                	Line (1,0);                } else if (i>24) {	                Line (0,1);	                Line (1,0);                } else if (i>12) {                	Line (1,0);                } else if (i>6) {                	Line (1,1);                } else {	                Line (0,0);                }            }    }}void Mandelbrot() {    //Mandelbrot    int sizex = windowWidth, sizey = windowHeight;    int maxiter = 64;    int x = 0, y = 0;    int zoom=150;     for (x = 0; x < 2*(float)sizex; x+=2) {        float xi = (float)x/zoom-2;        for (y = 0; y < (float)sizey; y+=2) {            float yi = (float)y / zoom;            float px = 0;            float py = 0;            int i;            for (i = 1; i < maxiter; i++) {                float xt;                if ( px*px+py*py > 4 ) {                    break;                }                xt = xi + px*px-py*py;                py = yi + 2*px*py;                px = xt;            }            if (i>4) { //6 //12 //24                MoveTo(x,(windowHeight/2)+y);                if (i>32) {                	Line (1,0);                	MoveTo(x,(windowHeight/2)+y+1);                	Line (1,0);                } else if (i>24) {	                Line (0,1);	                Line (1,0);                } else if (i>12) {                	Line (1,0);                } else if (i>6) {                	Line (1,1);                } else {	                Line (0,0);                }                MoveTo(x,(windowHeight/2)-y);                 if (i>32) {                	Line (1,0);                	MoveTo(x,(windowHeight/2)-y-1);                	Line (1,0);                } else if (i>24) {	                Line (0,1);	                Line (1,0);                } else if (i>12) {                	Line (1,0);                } else if (i>6) {                	Line (1,1);                } else {	                Line (0,0);                }            }        }    } }/* DrawContent()   Draws the content. */void DrawContent(short active) {    Rect	myRect;    SetPort(mwWindow);    EraseRect(&imageStart);    myRect = imageStart;           if (width==1) { // correct this to be a real choice for     	DrawBranch(windowWidth/2,0,90,9);        } else if (width==2) {    	Mandelbrot();    } else if (width==3) {        Julia();    }    }